# A65000 CPU #

**A65000**, aka A65k
-- a homage to the 6502 and M68000 CPU's --

Designed by Zoltán Majoros for the [RetroSim](https://github.com/arcanelab/RetroSim) fantasy computer.

The **A65000** microprocessor is an "imaginary" 32-bit CPU inspired by the 6502 and the Motorola 68k; and to a lesser extent, ARM processors. The main design goal was to create a CPU instruction set that most resembles the 6502, getting some inspirations from the 68K, and to make the instruction set as orthogonal as possible. Due to its simplicity and orthogonality, the A65000 is extremely simple to learn, especially if someone is already familiar with the 6502/68K processors.

The instruction set is small so that it's easy to learn, but due to its flexible addressing modes, it's quite powerful.

It has 16 registers, out of which 2 are reserved for the Program Counter and the Stack Pointer. Additionally, it has an 8-bit status register.

## Registers

| Register     | Size   | Notes                                                                 | 
| --------     | ----   | -----                                                                 | 
| `R0 - R13`   | 32 bit | 14 general purpose registers. They can hold either data or addresses. | 
| `PC`         | 32 bit | Program Counter                                                       | 
| `SP`         | 32 bit | Stack Pointer                                                         | 
| Status (`P`) | 8  bit | `–––IVCNZ`                                                            | 

## Instruction Set Overview

| Mnemonic  | Function                       | 
| --------  | --------                       | 
| **MOV**   | Move data between operands     | 
| **CLR**   | Set operand to zero            | 
|           |                                | 
| **ADD**   | Arithmetic addition            | 
| **SUB**   | Arithmetic subtraction         | 
| **ADC**   | Add with carry                 | 
| **SBC**   | Subtract with carry            | 
| **INC**   | Increase value                 | 
| **DEC**   | Decrease value                 | 
|           |                                |
| **SXB**   | Sign-extend byte               | 
| **SXW**   | Sign-extend word               | 
|           |                                | 
| **MUL**   | Multiplication                 | 
| **DIV**   | Division                       | 
|           |                                | 
| **AND**   | Binary AND operation           | 
| **OR**    | Binary OR operation            | 
| **XOR**   | Binary eXclusive OR operation  | 
| **SHL**   | Binary shift left              | 
| **SHR**   | Binary shift right             | 
| **ROL**   | Binary rotation left           | 
| **ROR**   | Binary rotation right          | 
|           |                                | 
| **SEC**   | Set C flag                     | 
| **CLC**   | Clear C flag                   | 
| **SEI**   | Set I flag                     | 
| **CLI**   | Clear I flag                   | 
| **SEV**   | Set V flag                     | 
| **CLV**   | Clear V flag                   | 
|           |                                | 
| **CMP**   | Comparison                     | 
|           |                                | 
| **BRA**   | Unconditional branch           | 
| **BEQ**   | Branch if Z=0                  | 
| **BNE**   | Branch if Z=1                  | 
| **BCC**   | Branch if C=0                  | 
| **BCS**   | Branch if C=1                  | 
| **BPL**   | Branch if N=0                  | 
| **BMI**   | Branch if N=1                  | 
| **BVC**   | Branch if V=0                  | 
| **BVS**   | Branch if V=1                  | 
| **BLT**   | Branch if Less Than            | 
| **BGT**   | Branch if Greater Than         | 
| **BLE**   | Branch if Less or Equal        | 
| **BGE**   | Branch if Greater or Equal     | 
|           |                                | 
| **JMP**   | Jump operation                 | 
| **JSR**   | Jump to subroutine             | 
| **RTS**   | Return from subroutine         | 
| **RTI**   | Return from interrupt          | 
|           |                                | 
| **PUSH**  | Push data to stack             | 
| **POP**   | Pop data from stack            | 
| **PUSHA** | Push all regsisters to stack   | 
| **POPA**  | Pop all registers from stack   |
| **PUSHS** | Push status register to stack  | 
| **POPS**  | Pop status register from stack |
|           |                                | 
| **BRK**   | Generate software interrupt    | 
| **NOP**   | No operation                   | 
|           |                                | 
| **SLP**   | Sleep until interrupt request  | 
|           |                                | 
| **SYS**   | System call                    |

## Size Specifier

Instruction format: `<mnemonic>[.size specifier] [operands]`

Instructions that deal with data can specify the size of the data in the operand. The default is 32 bits. A `.B` postfix after the mnemonic means 8-bit, a `.W` postfix means 16 bit data operation.

For example `MOV.B R0, 5` will copy 5 as a byte into `R0`, leaving the highest 3 byte of the 32-bit `R0` intact. `MOV.W R0, 6502` will move `6502` as a 16-bit number, leaving the highest 2 bytes of `R0` intact.

Finally, by omitting the size specifier, `MOV R0, 64` will copy 64 into `R0`, overwriting all 32-bits in the register.

## Addressing modes

Every instruction has zero, one or two operands.

If there are two operands, the first one is the destination, the second one is the source.

For example, `MOV R0, R1` will copy the contents of `R1` into `R0`.

Here are a few examples for each addressing mode:

`Rx = any of R0...R13, SP or PC`

### Immediate

    MOV Rx, constant

The size of the constant depends on the size specifier of the instruction. For example, `MOV.b r0, 121` translates the number 121 as a byte into the machine code, whereas `MOV.w r0, 121` would store 121 as a 16-bit word in the machine code. The default (when no size specifier is given) is 32 bits.

### Register

    MOV Rx, Ry 
    INC Rx

### Absolute

    MOV Rx, [Address]
    MOV [Address], Rx
    MOV [Address], const
    INC [Address]

### Register Indirect

    MOV Rx, [Ry]
    MOV [Rx], Ry
    MOV [Rx], const
    INC [Rx]

### Indexed

    MOV Rx, [Ry + const]
    MOV [Rx + const], Ry
    MOV [Rx + const], const

### Relative

    BEQ offset

### Implied

    CLC
    RTS

### Postfix Operators

When a register is dereferenced to access a memory address (in _Register Indirect_ and _Indexed_ addressing modes), you can use the `+`/`-` postfix operators to increase/decrease the value in the register. This is useful for loops or stack operations.

#### (+) Post-increment

The register gets incremented **after** the operation finishes.

Examples:
    
    MOV Rx, [Ry]+
    DEC [Rx]+
    MOV Rx, [Ry + const]+

#### (-) Pre-decrement

The register gets decremented **before** the operation begins.
    
Examples:

    MOV Rx, [Ry + const]-
    DEC [Rx]-
    MOV Rx, [Ry]-

The value of the post increment/decrement depends on the size specifier.

| size specifier | bits | change (bytes) | example           | note                     | 
| -------------- | ---- | -------------- | -------           | ----                     | 
| *-none-*       | 32   | 4              | `MOV r0, [r1]+`   | r1 gets incremented by 4 | 
| `W`            | 16   | 2              | `MOV.w r0, [r1]+` | r1 gets incremented by 2 | 
| `B`            | 8    | 1              | `MOV.b r0, [r1]+` | r1 gets incremented by 1 | 

The same logic applies with the pre-decrement modifier.

Pseudo code example:

    MOV R0, [R1]+

equals:


    R0 = R1;
    R1 += 4; // the data size is 32-bit, therefore we add 4.

Similarly:

    MOV.b R0, [R1]-

equals:

    R1 -= 1; // as the data size is 8-bit (.b), we subtract 1 from R1.
    R0 = R1

## IRQ's, Exceptions and System Vectors

The bottom of the memory hosts some important system vectors. Whenever a related system event occurs, the CPU reads out the corresponding vector from the specified address and sets the PC to the given value.

| Address | Vector description                              | 
| ------- | ------------------                              | 
| $0000   | Reset => PC                                     | 
| $0004   | Default Stack Pointer => SP                     | 
| $0008   | Illegal Instruction                             | 
| $000C   | Illegal Memory Address (address does not exist) | 
| $0010   | Division By Zero                                | 
| $0014   | Hardware IRQ                                    | 
| $0018   | Software IRQ (BRK Instruction)                  | 
| $001C   | NMI                                             | 

Whenever the CPU detects an external or software IRQ or an exception, it does the following steps:

*  (**IRQ/NMI Only**) finishes executing the current instruction
*  (**IRQ Only**) checks the `I` flag in the status register and if it's set, ignores the IRQ, otherwise continues the IRQ procedure
*  pushes the PC of the next instruction onto the stack
*  pushes the status register (8 bits) onto the stack
*  sets the PC to the appropriate vector address
*  (**IRQ/NMI Only**) when the interrupt handler finishes its job, it executes an `RTI` instruction, which restores the original flow of process.

## Instruction Timing

Rules for cycle counting: every 'atomic' step in an instruction takes one cycle to execute. Extra cycle is counted for each memory access that the CPU must do. For example:

    MOV R2, 34

The only 'atomic' step done is: `R2 = 34`, hence it takes one cycle to execute this instruction.

    MOV R4, [Address]  ; R4 = mem[Address]

The value assignment takes one cycle, plus one cycle for the memory read = 2 cycles.

    ADD [R1], 4   ; mem[R1] = mem[R1] + 4

Read-modify-write instructions need to access the memory twice, plus the addition takes a cycle, that is 3 cycles altogether.

    JSR $F09442
    
This is a multistep instruction. First, the PC of the next instruction is pushed onto the stack. Pushing to the stack means writing into the memory (`mem[SP] = value`), so far that's 2 cycles. Then the Stack Pointer must be adjusted (1), then the given address must be written into the PC (1). That's 4 cycles altogether.

## Instruction Encoding

See [Instruction Encoding](A65000-Instruction-Encoding.md)

## Detailed Instruction Set

See [Detailed Instruction Set](A65000-Instruction-Set.md)

## Assembler Syntax

See [Assembler Syntax](A65000-Assembler.md)
